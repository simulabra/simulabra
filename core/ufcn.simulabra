```
; Simulabra basic syntax (; is comment with JS equivalent)
~class ~point ~hash-trie ; class reference
34 "hi there" :my-name ; primitives (:my-name is symbol form of 'my_name')
%it ; argument/variable reference
5.sqrt ; message send
%p.x(5) ; message send with arg
~point.new ; basic constructor is `new` message on class
5.+(7) ; 5 + 7
4.*(3).*(2) ; (4 * 3) * 2
() (1 2 %three 16.sqrt) ; [] [1, 2, three, 16.sqrt()]
{ :prop-one :value :prop-two (1 2) } ; { prop_one: 'value', prop_two: [1, 2] }
~point.new({ :x 3 :y 4 }) ; new point{ x: 3, y: 4 }
.x(5) ; this.x(5)
.x.*(.y) ; this.x * this.y
$let(%v 4.*(8)) ; let v = 4 * 8
.log("v is" %v) ; this.log("v is", v)
$if(.x.<(10) ; thix.x < 10 ?
  .x(.x.+(1)) ; this.x(this.x + 1) :
  .x(.x./(2))) ; this.x(this.x / 2)
[^%it.x] ; it => { return it.x }
~const.new({
  :name :dumb-factor
  :value 10
})
[|%x %y| ^%x.+(%y).*(#dumb-factor)] ; (x, y) => { return (x + y) * DUMB_FACTOR; }
1.range(5).map([^%it.*(2)]).reduce([|%prev %cur| ^%prev.+(%cur)] 0) ; (1).range(5).map(_it => { return _it * 2 }).reduce((_prev, _cur) => { return _prev + _cur }, 0)
~macro.new({
  :name dist1
  :do [^`.,%it.-(%it.,%it).pow(2)] ; quasiquoting with `
})

~class.new({ ; define a new class
  :name :point ; name it 'point'
  :desc "2d point" ; describe it
  :components ( ; give it a list of components
    ~var.new({ :name :x :default 0 }) ; a variable x, default 0
    ~var.new({ :name :y :default 0 })
    ~method.new({ ; a method
      :name :cartesian-dist ; named 'cartesian-dist'
      :desc "cartesian distance to other point"
      :do [ ; _it => {
        $let({ ; let
          %dx $dist1(:x) ; _dx = (this.x - it.x).pow(2)
          %dy $dist1(:y)
        })
        ^%dx.+(%dy).sqrt ; return (_dx + _dy).sqrt()
      ] ; }
    })
    ~method.new({ ; a method
      :name :triangle-perimeter
      :do [|%a %b| ; (_a, _b) => {
        ^.dist(%a).+(.dist(%b)).+(%a.dist(%b)) ; return this.dist(_a) + this.dist(_b) + _a.dist(_b);
      ]
    })
  ]
})

~class.new({
  :name :color
  :components (
    ~var.new({ :name :r :default 0 })
    ~var.new({ :name :g :default 0 })
    ~var.new({ :name :b :default 0 })
    ~method.new({
      :name :hex
      :do [^(.r .g .b).map([%it.hex-string(2)]).join("")]
    })
  )
})

~class.new({
  :name :color-point
  :components (~point ~color)
})

~case.new({ ; test case
  :name :basic-point-test
  :do [
    $let({
      %p ~point.new
      %q ~color-point.new({ :x 3 :y 2 :r 53 :g 124 :b 37 })
    })
    %q.y(4)
    .assert-eq(%q.cartesian-dist(%p) 5)
  ]
})
```

Write a command line RPN calculator in Simulabra.
