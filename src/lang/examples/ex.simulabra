parameter grass_energy = 2
parameter sheep_energy = 4
parameter predate_relative_strength = 0.8

patch Grass {
  color green
}
patch Dirt {
  color brown
}

class Hunger {
  has Movement
  var energy type: Number default: 0

  on Movement.Move {
    energy.dec()
    if energy <= 0 {
      do Starve
    }
  }


  // action does this for us
  // message add_energy(n type: Num)
  // Hunger.AddEnergy(5) equivalent to Hunger.AddEnergy{ n: 5 }
  action AddEnergy(n type: Num) {
    energy += n
  }
  action Starve {
    log
    despawn()
  }
}

class Agent {
  keyword agent
  var id type: Number
}

message Attack {
  var from type: Predator
}

class Animal {
  var strength default: 10

  query relative_strength(other_strength: Number): Number {
    strength / other_strength
  }
  query dies_to(other: Predator): Bool {
    other.kills(self)
  }
}

class Predator {
  query kills(other: Animal): Bool {
    other.relative_strength(strength) < predate_relative_strength
  }
}

class Prey {
}

// also class Wolf of: Agent
class Wolf {
  of Agent
  has
    Hunger { energy: 100 },
    Position,
    Movement { speed: 2 }
  on spawn {
    randomize()
    wiggle(180)
  }

  on step {
    if sheep = within_range(Sheep, 2)
      point_towards(sheep)
    else
      wiggle()
    move()
  }

  on eat_sheep {
    log()
    var sheep = one_here(Sheep)?
    if kills
    sheep.die
    sheep.do_something {  }
    add_energy(sheep_energy)

  }
}

component Position {
  var x default: 0.0
  var y default: 0.0
}

function random_point(x, y, w, h) {
  return Position {
    x: random_f() * (w - x) + x,
    y: random_f() * (h - y) + y
  }
}

// var sb = SheepBox { sheep = s }
component SheepBox
  var sheep type: Sheep
end

for i in 0..50 {
  var pos = random_point(0, 0, 100, 100)
  // components should be unique so ordering shouldn't matter! just assume the default for the rest
  // real prototypical OO, and reveal non-default errors statically
  var s = Sheep { pos }
}

class Sheep {
  is Agent
  has Hunger { energy: 50 }
  has Position
  has Movement { speed: 1 }
  on spawn {
    randomize
    wiggle(180)
  }

  on step {
    do-first-of:
      patch_here() is Grass => eat_grass
      otherwise => wiggle and move
  }

  action eat_grass:
    set_patch(Dirt)
    Hunger.add_energy(grass_energy)

setup


# predefined

component Base:
  var id

  action spawn
  action despawn

component Position:
  var x
  var y

  fact patch:
    world.patch(x, y)
  fact nearby(other: Position, r = 1) -> bool:
  fact one_here(kind):
    world.query([kind, Position], k => nearby(k.position))
  fact within_range(kind, range)
    abs_diff(x, other.x).squared() + abs_diff(y, other.y).squared() < r.squared()
  action randomize:
    x = SampleRange(World.min_x, World.max_x)
    y = SampleRange(World.min_y, World.may_y)

component Movement:
  has Position
  # degrees
  var direction = 0
  let stride = 1

  action wiggle(deg = 50):
    direction += SampleRange(-deg, deg)
  action move:
    position.x += Math.cos(direction) * stride
    position.y += Math.sin(direction) * stride
