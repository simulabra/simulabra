parameter grass_energy = 2
parameter sheep_energy = 4
parameter predate_relative_strength = 0.8
parameter move_energy_use = 0.6
parameter idle_energy_use = 0.2

patch Grass {
  color green
}
patch Dirt {
  color brown
}




class hunger {
  has agent
  has movement

  var energy {
    type number
    default 100
  }

  on move(v: vec2) {
    energy->dec(move_energy_use)
    if energy <= 0 {
      do starve
    }
  }

  on step {
    energy->dec(idle_energy_use)
  }

  on add_energy(n) {
    energy->inc(1.0)
  }

  action Starve {
    do Despawn
  }
}

class agent {
  keyword agent
  var id type: Number
}

message Attack {
  var from type: Predator
}

class animal {
  has hunger

  var strength {
    default 10
    visible
  }

  query relative_strength(other: animal) -> Number {
    strength / other.strength
  }
  query dies_to(other: predator) -> boolean {
    other.kills(self)
  }

  query energy_provides -> number {
    hunger.energy
  }
}

class Predator {
  query kills(other: Animal): Bool {
    other.relative_strength(strength) < predate_relative_strength
  }
}

class Prey {
}

// also class Wolf of: Agent
agent Wolf {
  has Hunger(energy = 100)
  has Position
  has Movement(speed = Ref(speed))

  var speed = 100
  on Base.Spawn {
    Position.Randomize
    Movement.Wiggle(180)
  }

  on Movement.Step {
    if sheep = Position.WithinRange(target_type = Sheep, radius = 2) {
      Movement.PointTowards(sheep)
      TryEatSheep
    } else {
      Movement.Wiggle
    }
  }

  on TryEatSheep {
    Base.Log
    var sheep = Position.OneHere(target_type = Sheep)?
    if Predator.Kills(sheep) {
      delay sheep->Die
    }
    Hunger.AddEnergy(sheep->EnergyProvides)
  }
}

component Position {
  var x default: 0.0
  var y default: 0.0
}

function random_point(x, y, w, h) {
  return Position {
    x: random_f() * (w - x) + x,
    y: random_f() * (h - y) + y
  }
}

// var sb = SheepBox { sheep = s }
component SheepBox
  var sheep type: Sheep
end

for i in 0..50 {
  var pos = random_point(0, 0, 100, 100)
  // components should be unique so ordering shouldn't matter! just assume the default for the rest
  // real prototypical OO, and reveal non-default errors statically
  var s = Sheep { pos }
}

class Sheep {
  is Agent
  has Hunger { energy: 50 }
  has Position
  has Movement { speed: 1 }
  on spawn {
    randomize
    wiggle(180)
  }

  on step {
    do-first-of:
      patch_here() is Grass => eat_grass
      otherwise => wiggle and move
  }

  action eat_grass:
    set_patch(Dirt)
    Hunger.add_energy(grass_energy)

setup


# predefined

component Base:
  var id

  action spawn
  action despawn

component Position:
  var x
  var y

  fact patch:
    world.patch(x, y)
  fact nearby(other: Position, r = 1) -> bool:
  fact one_here(kind):
    world.query([kind, Position], k => nearby(k.position))
  fact within_range(kind, range)
    abs_diff(x, other.x).squared() + abs_diff(y, other.y).squared() < r.squared()
  action randomize:
    x = SampleRange(World.min_x, World.max_x)
    y = SampleRange(World.min_y, World.may_y)

component Movement:
  has Position
  # degrees
  var direction = 0
  let stride = 1

  action wiggle(deg = 50):
    direction += SampleRange(-deg, deg)
  action move:
    position.x += Math.cos(direction) * stride
    position.y += Math.sin(direction) * stride
